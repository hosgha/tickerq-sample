using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TickerqSourceGenerator;

[Generator]
public class JobAutoRegistrationGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;

        var timeRegistrations = new List<string>();
        var cronRegistrations = new List<string>();
        var compilation = context.Compilation;

        foreach (var methodDecl in receiver.Candidates)
        {
            if (!methodDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword)))
                continue;

            var model = compilation.GetSemanticModel(methodDecl.SyntaxTree);
            var methodSymbol = model.GetDeclaredSymbol(methodDecl) as IMethodSymbol;
            if (methodSymbol is null) continue;

            var attrs = methodSymbol.GetAttributes();

            // --- TickerFunction ---
            var tickerAttr = attrs.FirstOrDefault(a => a.AttributeClass?.Name == "TickerFunctionAttribute");
            if (tickerAttr is null) continue;

            string functionName = methodSymbol.Name;
            if (tickerAttr.ConstructorArguments.Length > 0)
            {
                var arg0 = tickerAttr.ConstructorArguments[0];
                if (arg0.Kind == TypedConstantKind.Primitive && arg0.Value is string s)
                    functionName = s;
            }

            // --- Cron detection ---
            var cronNamed = tickerAttr.NamedArguments.FirstOrDefault(kv => kv.Key == "cronExpression");
            if (!cronNamed.Equals(default(KeyValuePair<string, TypedConstant>)))
            {
                if (cronNamed.Value.Kind == TypedConstantKind.Primitive && cronNamed.Value.Value is string cronStr)
                {
                    cronRegistrations.Add(
                        $"await cronManager.AddAsync(new CronTickerEntity {{ Function = \"{functionName}\", CronExpression = \"{EscapeString(cronStr)}\" }});"
                    );
                }
                else
                {
                    var raw = GetAttributeArgumentRawText(methodDecl, "TickerFunction", "cronExpression");
                    if (!string.IsNullOrWhiteSpace(raw))
                    {
                        cronRegistrations.Add(
                            $"await cronManager.AddAsync(new CronTickerEntity {{ Function = \"{functionName}\", CronExpression = {raw} }});"
                        );
                    }
                }
                continue; // skip TimeJob if cronExpression is present
            }

            // --- TimeJob detection ---
            var timeAttr = attrs.FirstOrDefault(a => a.AttributeClass?.Name == "TimeJobAttribute");
            if (timeAttr is null) continue;

            string executionExpr = "DateTime.UtcNow";

            var execNamed = timeAttr.NamedArguments.FirstOrDefault(kv => kv.Key == "executionTime");
            if (!execNamed.Equals(default(KeyValuePair<string, TypedConstant>)))
            {
                if (execNamed.Value.Kind == TypedConstantKind.Primitive && execNamed.Value.Value is string dt)
                {
                    executionExpr = $"DateTime.Parse(\"{EscapeString(dt)}\").ToUniversalTime()";
                }
                else
                {
                    var raw = GetAttributeArgumentRawText(methodDecl, "TimeJob", "executionTime");
                    if (!string.IsNullOrWhiteSpace(raw))
                        executionExpr = raw;
                }
            }
            else if (timeAttr.ConstructorArguments.Length > 0)
            {
                var a0 = timeAttr.ConstructorArguments[0];
                if (a0.Kind == TypedConstantKind.Primitive && a0.Value is int sec)
                    executionExpr = sec == 0 ? "DateTime.UtcNow" : $"DateTime.UtcNow.AddSeconds({sec})";
            }

            timeRegistrations.Add(
                $"await timeManager.AddAsync(new TimeTickerEntity {{ Function = \"{functionName}\", ExecutionTime = {executionExpr} }});"
            );
        }

        if (timeRegistrations.Count == 0 && cronRegistrations.Count == 0)
        {
            context.AddSource("Job_Debug.g.cs", SourceText.From("// No jobs found", Encoding.UTF8));
            return;
        }

        var source = $$"""
            // <auto-generated> Job registrations
            using System;
            using System.Threading.Tasks;
            using TickerQ.Utilities.Entities;
            using TickerQ.Utilities.Interfaces.Managers;

            namespace TickerqSample.BackgroundJobs.Base
            {
                public partial class JobRegistrationService
                {
                    partial void RegisterJobs(
                        ITimeTickerManager<TimeTickerEntity> timeManager,
                        ICronTickerManager<CronTickerEntity> cronManager)
                    {
                        _ = RegisterJobsAsync(timeManager, cronManager);
                    }

                    private async Task RegisterJobsAsync(
                        ITimeTickerManager<TimeTickerEntity> timeManager,
                        ICronTickerManager<CronTickerEntity> cronManager)
                    {
                        try
                        {
                            // Time jobs
                            {{string.Join("\n                            ", timeRegistrations)}}

                            // Cron jobs
                            {{string.Join("\n                            ", cronRegistrations)}}

                            Console.WriteLine("[Jobs] SUCCESS: Registered {{timeRegistrations.Count}} time job(s) and {{cronRegistrations.Count}} cron job(s)");
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"[Jobs] FAILED: {ex}");
                        }
                    }
                }
            }
            """;

        context.AddSource("JobRegistrationService.Jobs.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string? GetAttributeArgumentRawText(MethodDeclarationSyntax methodDecl, string attributeSimpleName, string namedArgument)
    {
        var attr = methodDecl.AttributeLists
            .SelectMany(al => al.Attributes)
            .FirstOrDefault(a =>
            {
                var name = a.Name.ToString();
                return name.EndsWith(attributeSimpleName) || name.EndsWith(attributeSimpleName + "Attribute");
            });

        if (attr?.ArgumentList is null) return null;

        foreach (var arg in attr.ArgumentList.Arguments)
        {
            var name = arg.NameEquals?.Name.Identifier.Text;
            if (name == namedArgument)
                return arg.Expression.ToString();
        }
        return null;
    }

    private static string EscapeString(string s) =>
        s.Replace("\\", "\\\\").Replace("\"", "\\\"");

    class SyntaxReceiver : ISyntaxReceiver
    {
        public List<MethodDeclarationSyntax> Candidates { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is MethodDeclarationSyntax m &&
                m.AttributeLists.Count > 0 &&
                m.Modifiers.Any(SyntaxKind.StaticKeyword))
            {
                Candidates.Add(m);
            }
        }
    }
}
