using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TickerqSourceGenerator;

[Generator]
public class JobAutoRegistrationGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (!(context.SyntaxReceiver is SyntaxReceiver receiver)) return;

        var timeRegistrations = new List<string>();
        var compilation = context.Compilation;

        foreach (var methodDecl in receiver.Candidates)
        {
            if (!methodDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword)))
                continue;

            var model = compilation.GetSemanticModel(methodDecl.SyntaxTree);
            var methodSymbol = model.GetDeclaredSymbol(methodDecl);
            if (methodSymbol == null) continue;

            var attrs = methodSymbol.GetAttributes();

            // --- TickerFunction ---
            var tickerAttr = attrs.FirstOrDefault(a =>
            {
                var className = a.AttributeClass?.Name;
                return className == "TickerFunctionAttribute" || className == "TickerFunction";
            });
            if (tickerAttr == null) continue;

            string functionName = methodSymbol.Name;
            if (tickerAttr.ConstructorArguments.Length > 0 &&
                tickerAttr.ConstructorArguments[0].Kind == TypedConstantKind.Primitive &&
                tickerAttr.ConstructorArguments[0].Value is string fn)
            {
                functionName = fn;
            }

            // --- Cron detection ---
            string cronExpr = "";
            var cronNamed = tickerAttr.NamedArguments.FirstOrDefault(kv => kv.Key == "cronExpression");
            if (!cronNamed.Equals(default(KeyValuePair<string, TypedConstant>)))
            {
                if (cronNamed.Value.Kind == TypedConstantKind.Primitive && cronNamed.Value.Value is string s)
                {
                    cronExpr = $"\"{EscapeString(s)}\"";
                }
                else
                {
                    var rawText = GetAttributeArgumentRawText(methodDecl, "TickerFunction", "cronExpression");
                    cronExpr = rawText ?? "";
                }
            }
            else if (tickerAttr.ConstructorArguments.Length > 1 &&
                     tickerAttr.ConstructorArguments[1].Kind == TypedConstantKind.Primitive &&
                     tickerAttr.ConstructorArguments[1].Value is string s2)
            {
                cronExpr = $"\"{EscapeString(s2)}\"";
            }

            if (!string.IsNullOrEmpty(cronExpr))
            {
                continue;
            }

            // --- TimeJob detection ---
            var timeAttr = attrs.FirstOrDefault(a =>
            {
                var className = a.AttributeClass?.Name;
                return className == "TimeJobAttribute" || className == "TimeJob";
            });
            if (timeAttr == null) continue;

            string executionExpr = "DateTime.UtcNow";

            var execNamed = timeAttr.NamedArguments.FirstOrDefault(kv => kv.Key == "executionTime");
            if (!execNamed.Equals(default(KeyValuePair<string, TypedConstant>)))
            {
                if (execNamed.Value.Kind == TypedConstantKind.Primitive && execNamed.Value.Value is string dt)
                {
                    executionExpr = $"DateTime.Parse(\"{EscapeString(dt)}\").ToUniversalTime()";
                }
                else
                {
                    var raw = GetAttributeArgumentRawText(methodDecl, "TimeJob", "executionTime");
                    if (!string.IsNullOrWhiteSpace(raw))
                        executionExpr = raw;
                }
            }
            else if (timeAttr.ConstructorArguments.Length > 0 &&
                     timeAttr.ConstructorArguments[0].Kind == TypedConstantKind.Primitive &&
                     timeAttr.ConstructorArguments[0].Value is int sec)
            {
                executionExpr = sec == 0 ? "DateTime.UtcNow" : $"DateTime.UtcNow.AddSeconds({sec})";
            }

            timeRegistrations.Add(
                $"await timeManager.AddAsync(new TimeTickerEntity {{ Function = \"{functionName}\", ExecutionTime = {executionExpr} }});"
            );
        }

        if (timeRegistrations.Count == 0)
        {
            context.AddSource("JobRegistrationService.Jobs.g.cs", SourceText.From("// No jobs found", Encoding.UTF8));
            return;
        }

        var source = $$"""
            // <auto-generated> Job registrations
            using System;
            using System.Threading.Tasks;
            using TickerQ.Utilities.Entities;
            using TickerQ.Utilities.Interfaces.Managers;

            namespace TickerqSample.BackgroundJobs.Base
            {
                public partial class JobRegistrationService
                {
                    partial void RegisterJobs(
                        ITimeTickerManager<TimeTickerEntity> timeManager)
                    {
                        _ = RegisterJobsAsync(timeManager);
                    }

                    private async Task RegisterJobsAsync(
                        ITimeTickerManager<TimeTickerEntity> timeManager)
                    {
                        try
                        {
                            // Time jobs
                            {{string.Join("\n                            ", timeRegistrations)}}
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"[Jobs] FAILED: {ex}");
                        }
                    }
                }
            }
            """;

        context.AddSource("JobRegistrationService.Jobs.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetAttributeArgumentRawText(MethodDeclarationSyntax methodDecl, string attributeSimpleName, string namedArgument)
    {
        var attr = methodDecl.AttributeLists
            .SelectMany(al => al.Attributes)
            .FirstOrDefault(a =>
            {
                var name = a.Name.ToString();
                return name.EndsWith(attributeSimpleName) || name.EndsWith(attributeSimpleName + "Attribute");
            });

        if (attr == null || attr.ArgumentList == null) return null;

        foreach (var arg in attr.ArgumentList.Arguments)
        {
            if (arg.NameEquals != null && arg.NameEquals.Name.Identifier.Text == namedArgument)
                return arg.Expression.ToString();
        }
        return null;
    }

    private static string EscapeString(string s) =>
        s.Replace("\\", "\\\\").Replace("\"", "\\\"");

    class SyntaxReceiver : ISyntaxReceiver
    {
        public List<MethodDeclarationSyntax> Candidates { get; } = new List<MethodDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is MethodDeclarationSyntax m && m.AttributeLists.Count > 0)
                Candidates.Add(m);
        }
    }
}