// File: TimeJobAutoRegistrationGenerator.cs
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace TickerqSample.BackgroundJobs.Base;

[Generator]
public class TimeJobAutoRegistrationGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;

        var registrations = new List<string>();
        var compilation = context.Compilation;

        foreach (var method in receiver.Candidates)
        {
            var model = compilation.GetSemanticModel(method.SyntaxTree);

            // MUST be static
            if (!method.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword)))
                continue;

            // MUST have [TickerFunction]
            var tickerAttr = method.AttributeLists
                .SelectMany(a => a.Attributes)
                .FirstOrDefault(a => model.GetSymbolInfo(a).Symbol?.ContainingType?
                    .ToDisplayString() == "TickerQ.Utilities.Base.TickerFunctionAttribute");

            if (tickerAttr?.ArgumentList == null) continue;

            // Get function name
            string functionName = method.Identifier.Text;
            if (tickerAttr.ArgumentList.Arguments.Count > 0)
            {
                var arg = tickerAttr.ArgumentList.Arguments[0].Expression;
                if (model.GetConstantValue(arg).HasValue)
                    functionName = model.GetConstantValue(arg).Value?.ToString() ?? functionName;
            }

            // MUST have [TimeJob]
            var timeJobAttr = method.AttributeLists
                .SelectMany(a => a.Attributes)
                .FirstOrDefault(a => model.GetSymbolInfo(a).Symbol?.ContainingType?
                    .ToDisplayString() == "TickerqSample.BackgroundJobs.Base.TimeJobAttribute");

            if (timeJobAttr?.ArgumentList == null) continue;

            string executionExpr = "DateTime.UtcNow";

            var args = timeJobAttr.ArgumentList.Arguments;
            if (args.Count > 0)
            {
                // offsetSeconds
                if (args[0].NameEquals == null && model.GetConstantValue(args[0].Expression).Value is int sec)
                {
                    executionExpr = sec == 0 ? "DateTime.UtcNow" : $"DateTime.UtcNow.AddSeconds({sec})";
                }

                // executionTime = "2025-..."
                var execArg = args.FirstOrDefault(a => a.NameEquals?.Name.Identifier.Text == "executionTime");
                if (execArg != null && model.GetConstantValue(execArg.Expression).Value is string dt)
                {
                    executionExpr = $"DateTime.Parse(\"{dt}\").ToUniversalTime()";
                }
            }

            registrations.Add($"            await timeManager.AddAsync(new TimeTickerEntity {{ Function = \"{functionName}\", ExecutionTime = {executionExpr} }});");
        }

        if (registrations.Count == 0)
        {
            // Even if no jobs, generate something so we know it ran
            context.AddSource("TimeJob_Debug.g.cs", SourceText.From("// No TimeJob found", Encoding.UTF8));
            return;
        }

        var source = $$"""
            // <auto-generated> TimeJob registrations
            using System;
            using System.Threading.Tasks;
            using TickerQ.Utilities.Entities;
            using TickerQ.Utilities.Interfaces.Managers;

            namespace TickerqSample.BackgroundJobs.Base;

            public partial class JobRegistrationService
            {
                partial void RegisterTimeJobs(ITimeTickerManager<TimeTickerEntity> timeManager)
                {
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            {{string.Join("\n                            ", registrations)}}
                            Console.WriteLine($"[TimeJob] SUCCESS: Registered {registrations.Count} time job(s): {string.Join(", ", registrations.Select(r => r.Contains("Function = \"") ? r.Split('"')[1] : "unknown"))}");
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"[TimeJob] FAILED: {ex}");
                        }
                    });
                }
            }
            """;

        context.AddSource("JobRegistrationService.TimeJobs.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    class SyntaxReceiver : ISyntaxReceiver
    {
        public List<MethodDeclarationSyntax> Candidates { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is MethodDeclarationSyntax m &&
                m.AttributeLists.Count > 0 &&
                m.Modifiers.Any(SyntaxKind.StaticKeyword))
            {
                Candidates.Add(m);
            }
        }
    }
}